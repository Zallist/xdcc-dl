/*
Copyright 2015-2017 Hermann Krumrey

This file is part of xdcc-downloader.

xdcc-downloader is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

xdcc-downloader is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with xdcc-downloader.  If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * @author Hermann Krumrey <hermann@krumreyh.com>
 */

#include <iostream>
#include "HexChatPythonDownloader.h"

/**
 * Constructor
 * @param config - the configuration loaded while starting the program
 * @param serverList - the Server List Data Structure generated by the server and pack files
 */
HexChatPythonDownloader::HexChatPythonDownloader(Config config, ServerList serverList) {

    variableInit();
    this->config.push_back(config);
    this->serverList.push_back(serverList);

}

/**
 * Creates a script to download all packs saved in the server list data structure and
 * subsequently starts Hexchat
 */
void HexChatPythonDownloader::downloadAll() {

    download(this->serverList[0]);

}

/**
 * Adds a single pack to the pack file and updates the Server File Data Structure
 * @param addPackString - string of the form: "add /msg Bot xdcc send #X"
 */
void HexChatPythonDownloader::addSinglePack(string addPackString) {

    string packString = addPackString.erase(0, 4);
    this->serverList[0].addSinglePack(packString);

}

/**
 * Adds a single bot to the server file and updates the Server File Data Structure
 * @param addBotString - string of the form "add bot @ server/channel"
 */
void HexChatPythonDownloader::addSingleBot(string addBotString) {

    string botString = addBotString.erase(0, 4);
    this->serverList[0].addSingleBot(botString);

}

/**
 * Opens a text editor to edit the pack file
 */
void HexChatPythonDownloader::editPacks() {

    this->serverList[0].packEdit();

}

/**
 * Opens a text editor to edit the server file
 */
void HexChatPythonDownloader::editServers() {

    this->serverList[0].serverEdit();

}

/**
 * Downloads a single pack from an xdcc bot string
 * @param packString - string of the form "/msg Bot xdcc send #X"
 */
void HexChatPythonDownloader::downloadSinglePack(string packString) {

    ServerList tempList(this->config[0], packString);
    download(tempList);

}

/**
 * Prints all Servers, Channels, Bots and Packs to the console
 */
void HexChatPythonDownloader::printAll() {

    printMode("all");

}

/**
 * Prints all Packs wit their respective Servers, Channels and Bots.
 */
void HexChatPythonDownloader::printPacks() {

    printMode("packs");

}

//private

/**
 * Downloads all packs stored in a serverList data structure
 * @param serverList - the server list to be used
 */
void HexChatPythonDownloader::download(ServerList serverList) {

    vector<string> script;
    for (int i = 0; i < this->scriptStart.size(); i++) {
        script.push_back(this->scriptStart[i]);
    }

    vector<Server> servers = serverList.getServers();
    for (int i = 0; i < servers.size(); i++) {
        vector<Channel> channels = servers[i].getChannels();
        for (int j = 0; j < channels.size(); j++) {
            vector<Bot> bots = channels[j].getBots();
            for (int k = 0; k < bots.size(); k++) {
                vector<Pack> packs = bots[k].getPacks();
                for (int l = 0; l < packs.size(); l++) {
                    script.push_back("channels.append(\"newserver irc://" + servers[i].getName()
                                     + "/" + channels[j].getName() + "\")\n");
                    script.push_back("packs.append(\"msg " + bots[k].getName()
                                     + " xdcc send #" + packs[l].getPackNumberString() + "\")\n");
                }
            }
        }
    }

    for (int i = 0; i < this->scriptEnd.size(); i++) {
        script.push_back(this->scriptEnd[i]);
    }

    writeToFile(this->config[0].getScriptFileLocation(), script);

    system(this->config[0].getHexChatCommand().c_str());

    deleteFile(this->config[0].getScriptFileLocation());

}

/**
 * Prints the content of the server list to the console
 * @param mode  - decides the mode to print
 *                  -all: Prints everything
 *                  -packs: Only prints information relevant to the packs included
 */
void HexChatPythonDownloader::printMode(string mode) {

    string prevServer;
    string prevChannel;
    string prevBot;

    vector<Server> servers = this->serverList[0].getServers();
    for (int i = 0; i < servers.size(); i++) {
        vector<Channel> channels = servers[i].getChannels();
        if (!strcmp(mode.c_str(), "all")) { cout << servers[i].getName() << endl; }              //Mode: All - Server
        for (int j = 0; j < channels.size(); j++) {
            vector<Bot> bots = channels[j].getBots();
            if (!strcmp(mode.c_str(), "all")) { cout << "\t" + channels[j].getName() << endl; }  //Mode: All - Channel
            for (int k = 0; k < bots.size(); k++) {
                vector<Pack> packs = bots[k].getPacks();
                if (!strcmp(mode.c_str(), "all")) { cout << "\t\t" + bots[k].getName() << endl; }//Mode: All - Bot
                for (int l = 0; l < packs.size(); l++) {
                    if (!strcmp(mode.c_str(), "packs")) {                                        //Mode: Packs
                        if (strcmp(prevServer.c_str(), servers[i].getName().c_str())) {          //Check for Server
                            prevServer = servers[i].getName();
                            cout << prevServer << endl;
                        }
                        if (strcmp(prevChannel.c_str(), channels[j].getName().c_str())) {        //Check for Channel
                            prevChannel = channels[j].getName();
                            cout << "\t" + prevChannel << endl;
                        }
                        if (strcmp(prevBot.c_str(), bots[k].getName().c_str())) {                //Check for bot
                            prevBot = bots[k].getName();
                            cout << "\t\t" + prevBot << endl;
                        }
                    }
                    cout << "\t\t\t#" + packs[l].getPackNumberString() + "\n";
                }
            }
        }
        cout << "\n";
    }
}

//private

/**
 * Initializes standard variables used by this class
 */
void HexChatPythonDownloader::variableInit() {

    this->scriptStart = {"__module_name__ = \"xdcc_executer\"",
                         "__module_version__ = \"0.1\"",
                         "__module_description__ = \"Python XDCC Executer\"\n",
                         "import hexchat",
                         "import sys\n",
                         "def download(word, word_eol, userdata):",
                         "\thexchat.command(packs[0])",
                         "\treturn hexchat.EAT_HEXCHAT\n",
                         "def downloadComplete(word, word_eol, userdata):",
                         "\thexchat.command('quit')",
                         "\tchannels.pop(0)",
                         "\tpacks.pop(0)",
                         "\tif len(channels) == 0:",
                         "\t\tsys.exit(1)",
                         "\telse:",
                         "\t\thexchat.command(channels[0])",
                         "\treturn hexchat.EAT_HEXCHAT\n",
                         "def downloadFailed(word, word_eol, userdata):",
                         "\tfailed.append(packs[0])",
                         "\thexchat.command('quit')",
                         "\tchannels.pop(0)",
                         "\tpacks.pop(0)",
                         "\tif len(channels) == 0:",
                         "\t\tsys.exit(1)",
                         "\telse:",
                         "\t\thexchat.command(channels[0])",
                         "\treturn hexchat.EAT_HEXCHAT\n",
                         "failed = []",
                         "channels = []",
                         "packs = []\n"};

    this->scriptEnd = {"hexchat.command(channels[0])",
                       "hexchat.hook_print(\"You Join\", download)",
                       "hexchat.hook_print(\"DCC RECV Complete\", downloadComplete)",
                       "hexchat.hook_print(\"DCC STALL\", downloadFailed)",
                       "hexchat.hook_print(\"DCC RECV Abort\", downloadFailed)",
                       "hexchat.hook_print(\"DCC RECV Failed\", downloadFailed)",
                       "hexchat.hook_print(\"DCC Timeout\", downloadFailed)"};

}